<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="robots" content="noindex" />
    <link rel="dns-prefetch" href="https://unpkg.com">
    <title>CMS admin sveltia CMS</title>
  </head>
  <body>
    <!--
    This index can load sveltia or decap cms, just comment or uncomment the script you want to use.
    Huwindty uses sveltia CMS but you may prefer decap cms if you want certain features that are not yet implemented in sveltia (like workflow)
    -->
    <!-- <script src="https://unpkg.com/decap-cms@^3.0.0/dist/decap-cms.js"></script> -->
    <script src="https://unpkg.com/@sveltia/cms/dist/sveltia-cms.js" type="module"></script>

    <script>
      CMS.registerEditorComponent({
        // Internal id of the component
        id: "collapsible-note",
        // Visible label
        label: "Collapsible Note",
        // Fields the user need to fill out when adding an instance of the component
        fields: [
          {
            name: 'summary',
            label: 'Summary',
            widget: 'string'
          },
          {
            name: 'contents',
            label: 'Contents',
            widget: 'markdown'
          }
        ],
        // Regex pattern used to search for instances of this block in the markdown document.
        // Patterns are run in a multiline environment (against the entire markdown document),
        // and so generally should make use of the multiline flag (`m`). If you need to capture
        // newlines in your capturing groups, you can either use something like
        // `([\S\s]*)`, or you can additionally enable the "dot all" flag (`s`),
        // which will cause `(.*)` to match newlines as well.
        //
        // Additionally, it's recommended that you use non-greedy capturing groups (e.g.
        // `(.*?)` vs `(.*)`), especially if matching against newline characters.
        pattern: /^<details><summary>(.*?)<\/summary>(.*?)<\/details>$/ms,
        // Given a RegExp Match object
        // (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match#return_value),
        // return an object with one property for each field defined in `fields`.
        //
        // This is used to populate the custom widget in the markdown editor in the CMS.
        fromBlock: function(match) {
          return {
            summary: match[1],
            contents: match[2]
          };
        },
        // Given an object with one property for each field defined in `fields`,
        // return the string you wish to be inserted into your markdown.
        //
        // This is used to serialize the data from the custom widget to the
        // markdown document
        toBlock: function(data) {
          return `<details><summary>${data.summary}</summary>${data.contents}</details>`;
        },
        // Preview output for this component. Can either be a string or a React component
        // (component gives better render performance)
        toPreview: function(data) {
          return `
      <details>
        <summary>${data.summary}</summary>
      
        ${data.contents}
      
      </details>
      `;
        }
      });
      </script>

    <!-- <script>
      // Taken from demo https://github.com/decaporg/decap-cms/blob/main/dev-test/index.html
      const previewStyles = `
        html,
        body {
          color: #333;
          font-size: 14px;
          font-family: serif;
        }

        body {
          padding: 20px;
          background-color: #f9f9f9;
        }

        h1 {
          margin-top: 20px;
          color: #666;
          font-weight: bold;
          font-size: 32px;
        }

        img {
          max-width: 100%;
        }
      `;
      CMS.registerPreviewStyle(previewStyles, { raw: true });

      // from https://github.com/sveltia/sveltia-cms/issues/298
      const image = {
        image: {
          id: 'image',
          icon: 'image',
          label: get(_)('editor_components.image'),
          fields: [
        {
          name: 'src',
          label: get(_)('editor_components.src'),
          widget: 'image',
        },
        {
          name: 'alt',
          label: get(_)('editor_components.alt'),
          widget: 'string',
        },
        {
          name: 'title',
          label: get(_)('editor_components.title'),
          widget: 'string',
        },
        {
          name: 'className',
          label: get(_)('editor_components.className'),
          widget: 'string',
        },
      ],
      pattern: /!\[(.*?)\]\((.*?)(?: "(.*?)")?\)/,
      // eslint-disable-next-line jsdoc/require-jsdoc
      fromBlock: ([, alt, src, title, className]) => ({ src, alt, title, className }),
      // eslint-disable-next-line jsdoc/require-jsdoc
      toBlock: (props) => {
        const { src, alt, title, className } = escapeAllChars(props);

        return src ? `![${alt}](${src}${title ? ` "${title}"` : ''})${className ? `{.${className}}` : ''}` : '';
      },
      // eslint-disable-next-line jsdoc/require-jsdoc
      toPreview: (props) => {
        const { src, alt, title, className } = escapeAllChars(props);

        // Return `<img>` even if `src` is empty to make sure the `tagName` below works
        return `<img src="${src}" alt="${alt}" title="${title}" class="${className}">`;
      },
    },
      }
      CMS.registerEditorComponent(image);

      // from https://github.com/decaporg/decap-cms/blob/main/dev-test/index.html
      CMS.registerEditorComponent({
      id: "youtube",
      label: "Youtube",
      fields: [{name: 'id', label: 'Youtube Video ID'}],
      pattern: /^{{<\s?youtube (\S+)\s?>}}/,
      fromBlock: function(match) {
        return {
          id: match[1]
        };
      },
      toBlock: function(obj) {
        return '{{< youtube ' + obj.id + ' >}}';
      },
      toPreview: function(obj) {
        return (
          '<img src="http://img.youtube.com/vi/' + obj.id + '/maxresdefault.jpg" alt="Youtube Video"/>'
        );
      }
    });
    </script> -->
  </body>
</html>
